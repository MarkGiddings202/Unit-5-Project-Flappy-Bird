import {
	SpriteData,
	FontData,
	BitmapFontData,
	SoundData,
	ShaderData,
	TextureOpt,
} from "./types"

import {
	Vec2,
	Quad,
} from "./math"

import {
	Event,
	isDataURL,
} from "./utils"

import {
	Texture,
} from "./gfx"

const SPRITE_ATLAS_WIDTH = 2048
const SPRITE_ATLAS_HEIGHT = 2048

class Asset<D> {
	loaded: boolean = false
	data: D | null = null
	error: Error | null = null
	private onLoadEvents: Event<[D]> = new Event()
	private onErrorEvents: Event<[Error]> = new Event()
	private onFinishEvents: Event<[]> = new Event()
	constructor(loader: Promise<D>) {
		loader.then((data) => {
			this.data = data
			this.onLoadEvents.trigger(data)
		}).catch((err) => {
			this.error = err
			if (this.onErrorEvents.numListeners() > 0) {
				this.onErrorEvents.trigger(err)
			} else {
				throw err
			}
		}).finally(() => {
			this.onFinishEvents.trigger()
			this.loaded = true
		})
	}
	static loaded<D>(data: D): Asset<D> {
		const asset = new Asset(Promise.resolve(data)) as Asset<D>
		asset.data = data
		asset.loaded = true
		return asset
	}
	onLoad(action: (data: D) => void) {
		this.onLoadEvents.add(action)
		return this
	}
	onError(action: (err: Error) => void) {
		this.onErrorEvents.add(action)
		return this
	}
	onFinish(action: () => void) {
		this.onFinishEvents.add(action)
		return this
	}
	then(action: (data: D) => void): Asset<D> {
		return this.onLoad(action)
	}
	catch(action: (err: Error) => void): Asset<D> {
		return this.onError(action)
	}
	finally(action: () => void): Asset<D> {
		return this.onFinish(action)
	}
}

class AssetBucket<D> {
	assets: Map<string, Asset<D>> = new Map()
	lastUID: number = 0
	add(name: string | null, loader: Promise<D>): Asset<D> {
		// if user don't provide a name we use a generated one
		const id = name ?? (this.lastUID++ + "")
		const asset = new Asset(loader)
		this.assets.set(id, asset)
		return asset
	}
	addLoaded(name: string | null, data: D): Asset<D> {
		const id = name ?? (this.lastUID++ + "")
		const asset = Asset.loaded(data)
		this.assets.set(id, asset)
		return asset
	}
	get(handle: string): Asset<D> | void {
		return this.assets.get(handle)
	}
	progress(): number {
		if (this.assets.size === 0) {
			return 1
		}
		let loaded = 0
		this.assets.forEach((asset) => {
			if (asset.loaded) {
				loaded++
			}
		})
		return loaded / this.assets.size
	}
}

class TexPacker {
	private gl: WebGLRenderingContext
	private tex: Texture
	private canvas: HTMLCanvasElement
	private ctx: CanvasRenderingContext2D
	private x: number = 0
	private y: number = 0
	private curHeight: number = 0
	private opt: { onCleanup: TextureOpt["onCleanup"] }
	constructor(gl: WebGLRenderingContext, w: number, h: number, opt: TexPacker["opt"]) {
		this.opt = opt
		this.canvas = document.createElement("canvas")
		this.canvas.width = w
		this.canvas.height = h
		this.tex = Texture.fromImage(gl, this.canvas, opt)
		this.ctx = this.canvas.getContext("2d")
	}
	add(img: TexImageSource): [Texture, Quad] {
		if (img.width > this.canvas.width || img.height > this.canvas.height) {
			throw new Error(`Texture size (${img.width} x ${img.height}) exceeds limit (${this.canvas.width} x ${this.canvas.height})`)
		}
		if (this.x + img.width > this.canvas.width) {
			this.x = 0
			this.y += this.curHeight
			this.curHeight = 0
		}
		if (this.y + img.height > this.canvas.height) {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
			this.tex = Texture.fromImage(this.gl, this.canvas, this.opt)
			this.x = 0
			this.y = 0
			this.curHeight = 0
		}
		const pos = new Vec2(this.x, this.y)
		this.x += img.width
		if (img.height > this.curHeight) {
			this.curHeight = img.height
		}
		if (img instanceof ImageData) {
			this.ctx.putImageData(img, pos.x, pos.y)
		} else {
			this.ctx.drawImage(img, pos.x, pos.y)
		}
		this.tex.update(this.canvas)
		return [this.tex, new Quad(
			pos.x / this.canvas.width,
			pos.y / this.canvas.height,
			img.width / this.canvas.width,
			img.height / this.canvas.height,
		)]
	}
}

export default (gopt: {
	gl: WebGLRenderingContext
	onCleanup: () => void,
}) => {

	const assets = {
		// prefix for when loading from a url
		urlPrefix: "",
		// asset holders
		sprites: new AssetBucket<SpriteData>(),
		fonts: new AssetBucket<FontData>(),
		bitmapFonts: new AssetBucket<BitmapFontData>(),
		sounds: new AssetBucket<SoundData>(),
		shaders: new AssetBucket<ShaderData>(),
		custom: new AssetBucket<any>(),
		packer: new TexPacker(gopt.gl, SPRITE_ATLAS_WIDTH, SPRITE_ATLAS_HEIGHT, { onCleanup: gopt.onCleanup }),
		// if we finished initially loading all assets
		loaded: false,
	}

	// wrapper around fetch() that applies urlPrefix and basic error handling
	function fetchURL(path: string) {
		const url = assets.urlPrefix + path
		return fetch(url)
			.then((res) => {
				if (!res.ok) throw new Error(`Failed to fetch ${url}`)
				return res
			})
	}

	function fetchJSON(path: string) {
		return fetchURL(path).then((res) => res.json())
	}

	function fetchText(path: string) {
		return fetchURL(path).then((res) => res.text())
	}

	function fetchArrayBuffer(path: string) {
		return fetchURL(path).then((res) => res.arrayBuffer())
	}

	// wrapper around image loader to get a Promise
	function loadImg(src: string): Promise<HTMLImageElement> {
		const img = new Image()
		img.crossOrigin = "anonymous"
		img.src = isDataURL(src) ? src : assets.urlPrefix + src
		return new Promise<HTMLImageElement>((resolve, reject) => {
			img.onload = () => resolve(img)
			img.onerror = () => reject(new Error(`Failed to load image from "${src}"`))
		})
	}

	// wrap individual loaders with global loader counter, for stuff like progress bar
	function load<T>(prom: Promise<T>): Asset<T> {
		return assets.custom.add(null, prom)
	}

	// get current load progress
	function loadProgress(): number {
		const buckets = [
			assets.sprites,
			assets.sounds,
			assets.shaders,
			assets.fonts,
			assets.bitmapFonts,
			assets.custom,
		]
		return buckets.reduce((n, bucket) => n + bucket.progress(), 0) / buckets.length
	}

	function setLoadRoot(path: string) {
		assets.urlPrefix = path
	}

	return {
		load,
		loadProgress,
		setLoadRoot,
	}

}
